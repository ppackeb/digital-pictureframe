<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="stylesheet" href="webApp.css">     
  <link rel="icon" type="image/x-icon" href="../renderer/assets/images/favicon.ico">
  <link rel="apple-touch-icon" sizes="180x180" href="../renderer/assets/images/favicon.png">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">  
  <title>IP Addresses and Ports</title>   
</head>

<body onload='initialize()'>
  <header>
    <h3>IP Addresses and Port</h3>
  </header>

  <section class="center-section">
    
    <h4>Local IPv4</h4>
    <div id ="labelipv4"></div>
    <div id="qrcodeipv4" ></div>

    <h4>Local IPv6</h4>
    <div id ="labelipv6"></div>
    <div id="qrcodeipv6" ></div>    
  </section>

  <section class="bottom-buttons">        
    <input type="image" id="home" name="home" src="../renderer/assets/images/home.png" onclick="location.href='/appOptions';">
  </section>   



<script type='text/javascript' src='appServer.js'></script>
<script type="text/javascript" src="../../common/qrcode.js"></script>
<script src="../../common/customAlert.js"></script> 
<script>


  var qrcodeipv6 = new QRCode(document.getElementById("qrcodeipv6"), {
    width : 150,
    height : 150    
  });
  var qrcodeipv4 = new QRCode(document.getElementById("qrcodeipv4"), {
    width : 150,
    height : 150
  });



  async function initialize(){
    data = await PrepMessage('app_readDB');    
    ip_local(data.appPort);            
  }

  async function PrepMessage(payload){  
    messagePayload = null;
    switch (payload){
      case 'app_readDB':
        messagePayload = {command:"app_readDB", data:null};
      break;            
      case 'app_getQRCode':
        messagePayload = {command:"app_getQRCode", data:null};
      break;
    }  
    try {
      // Await the response from the new, async makeRequest function.
      returnData = await makeRequest('/app_sendrequest', messagePayload);
      command = returnData.command;
      data = returnData.data;
      // Handle the response based on the command.
      switch(messagePayload.command){
        case 'app_readDB':
          return data;
        break;
        case 'app_getQRCode':
          return data;
        break;
        default:          
        break;
      }      
    } catch (error) {        
      //ShowAlert('Error in html POST. '+ error, false).then((result) => { })  
    }         
  }

  async function ip_local(g_appPort){ 
    addresses = await PrepMessage('app_getQRCode');        
    if (addresses.ipv6.length != 0) { // The ipv6 array is not empty     
      document.getElementById('labelipv6').style.wordBreak = "break-word";         
      document.getElementById("labelipv6").textContent = addresses.ipv6 + ':' + g_appPort;          
      let finalIP = "http://[" + addresses.ipv6 + "]:" + g_appPort;              
      qrcodeipv6.makeCode(finalIP);                                      
    }else{
      document.getElementById('qrcodeipv6').parentElement.style.verticalAlign = "top";
      document.getElementById('qrcodeipv6').style.whiteSpace = "normal";
      document.getElementById('qrcodeipv6').style.wordBreak = "break-word";
      document.getElementById('qrcodeipv6').textContent = 'IPv6 is not currently enabled in the network settings of the computer';        
    }
    if (addresses.ipv4.length != 0) {        
      document.getElementById("labelipv4").textContent = addresses.ipv4  + ':' + g_appPort;
      let finalIP = "http://" + addresses.ipv4 + ":" + g_appPort;
      qrcodeipv4.makeCode(finalIP);
    }else{
      document.getElementById('labelipv4').parentElement.style.verticalAlign = "top";
      document.getElementById('labelipv4').style.whiteSpace = "normal";
      document.getElementById('labelipv4').style.wordBreak = "break-word";
      document.getElementById('labelipv4').textContent = 'IPv4 is not currently enabled in the network settings of the computer';        
    }
  }

</script>
</body>
</html>