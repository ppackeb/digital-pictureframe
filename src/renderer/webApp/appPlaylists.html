
<!DOCTYPE html>
<html>
<head>  
  <link rel="stylesheet" href="base.css">     
  <link rel="icon" type="image/x-icon" href="../renderer/assets/images/favicon.ico">
  <link rel="apple-touch-icon" sizes="180x180" href="../renderer/assets/images/favicon.png">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">  
  <title>Playlists</title> 
</head>
  

<body onload='initialize()'>
  <header>
    <h3>Manage Playlists</h3>
  </header>
    
  <section class="scrollable-folder-table large">    
    <table class="folder-table" id="playlists">          
      <colgroup>
        <col class="folder-name">
        <col class="folder-icon">
      </colgroup>              
    </table>    
  </section>
      
  <div class="bottom-buttons-images">
    <input type="image" id="home" name="home" src="../renderer/assets/images/home.png"  onclick="location.href='/appOptions';">
    <input type="image" id="newPlaylist" name="newPlaylist" src="../renderer/assets/images/plusicon.png" onclick="NewPlaylist()">
  </div>
   

<script type='text/javascript' src='appServer.js'></script>
<script src="../../common/customAlert.js"></script> 
<script>

  let playlistNames = null;

  async function PrepMessage(payload){  
    messagePayload = null;
    switch (payload){
      case 'app_readDB':
        messagePayload = {command:"app_readDB", data: null};
      break;              
    }  
    try {
      // Await the response from the new, async makeRequest function.
      returnData = await makeRequest('/app_sendrequest', messagePayload);
      command = returnData.command;
      data = returnData.data;
      // Handle the response based on the command.
      switch(messagePayload.command){
        case 'app_readDB':
          return data;
        break;
        default:          
        break;
      }      
    } catch (error) {        
      //ShowAlert('Error in html POST. '+ error, false).then((result) => { })  
    } 
  }
  

  async function initialize(){
    returnData = await PrepMessage('app_readDB')
    WriteUI(returnData);        
  }

function WriteUI(data) {
  playlists = data.playlists;
  SelectedPlaylist = data.selplaylist;  
  const playlistTable = document.getElementById("playlists");

  playlistNames = Object.keys(playlists);

  // Sort by the second part (displayName) in a case-insensitive manner
  playlistNames.sort((a, b) => {
    const nameA = a.split('_')[1]?.toLowerCase() || '';
    const nameB = b.split('_')[1]?.toLowerCase() || '';
    return nameA.localeCompare(nameB);
  });

  playlistNames.forEach((name, index) => {
    parts = name.split('_');
    displayName = parts[1];
    PlaylistFullName = name.replace(/^playlist_/, '');
    
    let newRow = playlistTable.insertRow();
    
      // Highlight if this is the selected playlist
    if (PlaylistFullName === SelectedPlaylist) {
      newRow.innerHTML = `<td>${displayName}</td> <td><img src="../renderer/assets/images/app star.png"></td>`;
    }else{
      newRow.innerHTML = `<td>${displayName}</td> <td></td>`;            
    }     

  });
}

  document.getElementById("playlists").addEventListener("click", function(event) {
    // Find the nearest parent <tr> of the clicked element
    const row = event.target.closest("tr");

    // Make sure the click was on a row inside the table body
    if (row && document.getElementById("playlists").contains(row)) {
      // Do something with the row            
      selectedPlaylist = playlistNames[row.rowIndex];
      location.href = `/appEditPlaylist?value=${encodeURIComponent(selectedPlaylist)}`;
    }
  });

  function NewPlaylist(){
    location.href = `/appEditPlaylist?value=${encodeURIComponent('')}`;
  }

</script>
</body> 
</html>
