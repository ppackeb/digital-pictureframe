<!DOCTYPE html>
<html lang="en">
<head>
</head>
<body>    
  <script type="text/javascript" src="../../common/requireModule.js"></script>    
  <script type='text/javascript' src="../../common/DBFunctions.js"></script>      
  <script type='text/javascript' src="../display.js"></script>       
<script>  


  var dir_array_weight =[];
  var dirlist = [];
  var new_name;


//.invoke/.handle is used for request-response pattern
//.send/.on is used for fire-and-forget or one-way messages

ipcRenderer.on("appSendRequest", async function (event, data) {
  // 1. Destructure the request_id from the incoming data object.
  const { request_id, ...payloadWithoutId } = data;

  // Use the payload without the ID for processing.
  const command = payloadWithoutId.command;
  const requestData = payloadWithoutId.data;
  const messagePayload = { command: command, data: requestData }; // Reconstruct the payload without request_id

  let responseData = null; // Initialize a variable to hold the response data  
  let response = {command: command, data: null}; // Default response structure  

  switch (command) {
    case 'AppSaveEXIFData':
      appSaveEXIFData(requestData);
      // returns standard response with null data 
    break;

    case 'app_readMetaData':
      responseData = await ipcRenderer.invoke('app_readMetaData', messagePayload);
      response = {
        command: command,
        data: responseData
      };  
    break;
    
    case 'appSetHideShowImages':
      appSetHideShowImages(data.data);  
      // returns standard response with null data 
    break;

    case 'appRebuildAll':
      responseData = await rebuildall(); // from dbfunctions.js
      response = {
        command: command,
        data: responseData
      }; 
    break;

    case 'GethideImagesState':
      readDataBase();
      response = {
        command: command,
        data: g_hideImages  // g_hideImages is a global in DBFunctions.js
      }; 
    break;

    case 'GetMutePlayState':          
      responseData = await ipcRenderer.invoke('GetMutePlay', messagePayload);
      response = {
        command: command,
        data: responseData
      };                            
    break;

    case 'app_getQRCode':
      responseData = await ipcRenderer.invoke('get-local-ips', messagePayload);
      response = {
        command: command,
        data: responseData
      }; 
    break;

    case 'app_readDB':
      readDataBase();
      playlists = readPlaylistPaths();
      responseData = {
        playlists: playlists,
        selplaylist: g_selPLAYLIST.substring('playlist_'.length),
        prefetch: g_prefetchNUM,
        preload: g_preloadNUM,
        basedelay: g_basedelay,
        nightlyrebuild: g_nightlyrebuild,
        startPauseTime: g_startPauseTime,
        stopPauseTime: g_stopPauseTime,
        appStartDir: g_appStartDir,
        appPort: g_appPort
      };           
      response = {
        command: command,
        data: responseData
      }; 
    break;

    case 'app_writeDB':
      appWriteDB(requestData);
      // returns standard response with null data
    break;

    case 'direction':
    case 'information':
    case 'filectrl':
    case 'volume':
      ipcRenderer.send('pass_appInfo', messagePayload);
      // returns standard response with null data
    break;

    case 'ImageDir':
      responseData = await getStartDir(requestData);
      response = {
        command: command,
        data: responseData
      };       
    break;

    case 'NewPlaylist':
      responseData = await NewPlaylist(requestData);
      response = {
        command: command,
        data: responseData
      }; 
    break;

    case 'ZoomImage':
      ipcRenderer.send('appZoomLocation',data);             
      // returns standard response with null data
    break;

    case 'DeletePlaylist':
      DeletePlaylist(requestData);
      // returns standard response with null data
    break;

    case 'readMarkedFileList':
      responseData = await readMarkedFileList();
      response = {
        command: command,
        data: responseData
      }; 
    break;

    case 'DeleteMarkedFilesList':        
      ClearRotateDelete(); // DBFunctions.js          
      // returns standard response with null data
    break;

    case 'refresh':      
      ipcRenderer.send('resetdisplaywindow',' '); 
      // returns standard response with null data
    break;

    default:
      const msg = 'appSendRequest - command not found or not implemented: ' + command;
      //writeRotateDeleteError(null, null, msg);
      return;
      // returns standard response with null data
    break;
  }
  ipcRenderer.send('app_sendrequest_response', {request_id: request_id, responseData: response});
});


  async function appSaveEXIFData(data){
    existingHiddenFlag = "";
    if (data.dbEXIFHiddenImages == true){      
      existingHiddenFlag = 'Hiddenflag=Hidden ';
    }

    const existingComment = data.dbEXIFImageComments ? data.dbEXIFImageComments.trim() : "";
    const updatedComment = existingHiddenFlag + existingComment;   

    // Check if extension is jpg or jpeg before writing EXIF
    const ext = data.ImagePath.split('.').pop().toLowerCase();
    try{
      if (ext === 'jpg' || ext === 'jpeg') {
        await exiftool.write(data.ImagePath, { UserComment: updatedComment }, ["-overwrite_original"]);
      } else {                        
        await addCommentToMP4(data.ImagePath, updatedComment);              
      }
    } catch (error){
      writeRotateDeleteError(null, null, 'Error writing EXIF data:', error);      
    }
  }



  async function addCommentToMP4(filePath, commentString) {    
    return new Promise((resolve, reject) => {
        const tempFilePath = filePath.replace(/\.mp4$/, '_temp.mp4');
        const args = [
          '-i', filePath,
          '-metadata', `comment=${commentString}`,
          '-c', 'copy',
          tempFilePath
        ];
             const ffmpegPath = path.join(__dirname, '..', 'renderer', 'assets', 'ffmpeg', 'ffmpeg.exe');
        const ffmpegProcess = execFile(ffmpegPath, args, (error, stdout, stderr) => {
          if (error) {            
            cleanupTempFile(tempFilePath); // Ensure temp file is cleaned up   
            writeRotateDeleteError(null, null, `Failed to add comment to MP4: ${stderr}`);         
            reject();
            return;
          }
        });

        // Wait for the ffmpeg process to fully close
      ffmpegProcess.on('close', (code) => {
        if (code !== 0) {          
          writeRotateDeleteError(null, null, `FFmpeg process exited with code ${code}`);
          cleanupTempFile(tempFilePath); // Ensure temp file is cleaned up
          reject();
          return;
        }

          // Proceed with file operations after ffmpeg has completed
        fs.unlink(filePath, (unlinkError) => {
          if (unlinkError) {
            writeRotateDeleteError(null, null, 'Error deleting original file:', unlinkError, 'cannot replace file');            
            // Cleanup the temp file and resolve without deleting filePath
            cleanupTempFile(tempFilePath);
            reject();
            return;
          }

          fs.rename(tempFilePath, filePath, (renameError) => {
            if (renameError) {
              writeRotateDeleteError(null, null, 'Error replacing original file:', renameError);              
              cleanupTempFile(tempFilePath); // Ensure temp file is cleaned up
              reject();
              return;
            }                                
            resolve();
          });
        });
      });
    });
  }

  // Helper function to clean up the temp file
  function cleanupTempFile(tempFilePath) {
    fs.unlink(tempFilePath, (err) => {
      if (err) {
        errormsg = `Failed to clean up temp file (${tempFilePath}):`, err.message
        writeRotateDeleteError(null, null, errormsg); // located in DBFunctions.js
       
      }
    });
  }

  async function appSetHideShowImages(data){
    readDataBase();  
    g_hideImages = data ? '1' : '0';   
    writeDataBase();     
    ipcRenderer.send('resetdisplaywindow',' ');         
  }


  


  async function readMarkedFileList(){        
    readDataBase();// read playlist data and paths into DBFunctions.js    
    rotate_delete_error = readRotateDeleteError(); // located in DBFunctions.js
    return rotate_delete_error;
  }

  function DeletePlaylist(data){        
    db.prepare('DROP TABLE IF EXISTS '+ data).run(); // drop selected playlist table
    var tablenamearray = readPlaylistTableNames();
    playlistHolder = g_selPLAYLIST;
    g_selPLAYLIST = 'playlist_'+ tablenamearray[0];    
    writeDataBase();
    ipcRenderer.send('playlist_updated', ''); 
    // if the running playlist is the deleted playlist, reset display with next playlist in the database table    
    if (data == playlistHolder){      
      ipcRenderer.send('resetdisplaywindow', ''); 
    }
  }
  

  async function NewPlaylist(data){
    let PlaylistCreated = false;
    playlistdirs = data.playlistDir;
    new_name = data.playlistname;
    if (Array.isArray(playlistdirs)){
      dirlist = Array.from(playlistdirs);  
    }else{
      dirlist[0] = playlistdirs;  
    }    
    ipcRenderer.send('popup','Building Index'); 
    try{
      PlaylistCreated = await CreateAddPlaylistTable(new_name,dirlist, true);                                         
    }catch (err){
      //writeRotateDeleteError(null, null, 'Error creating playlist table: '+ new_name + ' ' + err.message);   
      PlaylistCreated = false;   
    }    
      ipcRenderer.send('playlist_updated', '');         
      ipcRenderer.send('close_popup', '');    
      return PlaylistCreated;
  }



   
  async function getStartDir(SelectedDir) { 
    var results = [];   
    readDataBase();// read playlist data and paths into DBFunctions.js        
    if (SelectedDir == 'TopDir') {                 
      if (g_appStartDir.charAt(0) =='\\'){  // just in cased a server path is chosen eg. \\diskstation\photo then dont add escape code \
        results.push(g_appStartDir);  
        SelectedDir = g_appStartDir;            
      }else{
        results.push(g_appStartDir);  
        SelectedDir = g_appStartDir.replace(/\\/g, '\\\\');            
      }                  
    }else{
      results.push(SelectedDir);  
    }
    returndata = {command: "startdir", data:null}; // dummy object to populate for return    
    try{
      await fs.readdirSync(SelectedDir).sort().forEach(function (dirContent) {              
        dirContentPath = path.resolve(SelectedDir, dirContent);
        try{  // added try:catch here as statSync throse a EBUSY error if a locked file or directory is tested
          if (fs.statSync(dirContentPath).isDirectory() && dirContent.charAt(0) != '#' && dirContent.charAt(0) != '.' && dirContent.charAt(0) !='$') {
              results.push(dirContentPath);
          }
        }catch (err){
          
        }
      });
      returndata.data = results        
    }catch (err){
      returndata.data = 'bad dir';        
    }      
    return returndata;
  }


</script>
</body>     
</html>
