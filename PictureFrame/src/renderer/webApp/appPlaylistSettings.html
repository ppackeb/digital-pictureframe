<!DOCTYPE html>
<html>

<head>
  <style>  
  select{
    width: 80%;
  }
  /* Optional: add a "disabled" state */
  .disabled-overlay {
    pointer-events: none;   /* disables mouse interaction */
    opacity: 0.6;           /* optional visual cue */
  }
</style>    
   <link rel='stylesheet' href='WebApp.css'>
  <link rel="icon" type="image/x-icon" href="../renderer/assets/images/favicon.ico">  
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">  
</head>

<body onload="initialize()">  
  <div style="height: 1.5em;">
    <b><center>Configuration Settings</center></b>  
  </div>
  <label>Current Playlist</label>
  <br>
  <select name ="playlist_name" id="playlist_name" ></select>  
  <br>
  <br>
  <label>Item Display Time</label>
  <br>
  <select id="baseDELAY" name="baseDELAY" >    
    <option value="5000">5 seconds</option>
    <option value="10000">10 seconds</option>
    <option value="15000">15 seconds</option>
    <option value="20000">20 seconds</option>
    <option value="30000">30 seconds</option>
  </select>
  <br>
  <br>
  <label>Items to Queue</label>
  <br>
  <select id="preloadNUM" name="preloadNUM" onchange ='prefetchcheck()' >
    <option value="1">1 </option>  
    <option value="5">5 </option>  
    <option value="10">10 </option>
    <option value="20">20 </option>
    <option value="30">30 </option>     
  </select>
    <br>
  <br>
  <label>Items per Folder to Queue</label>
  <br>  
  <select id="prefetchNUM" name="prefetchNUM" onchange ='prefetchcheck()' >
    <option value="1">1 </option>      
    <option value="5">5 </option>
    <option value="10">10 </option>        
  </select>  
  <br>
  <p></p>            
  <label for="AppStartDirectory">Top Item Folder</label>
  <br>
  <input style="width: 75%; text-overflow: ellipsis;" readonly type="text" id="AppStartDirectory" name="AppStartDirectory" type="text" id="AppStartDirectory" name="AppStartDirectory" />

    <!-- this section contains everything for my modal-->  
  <section class="modal hidden">
    <div class="flex">
      <input type ="text" id="dirPath" name="dirPath"  class="full-width-input" > 
      <input type="image" id="help" name="help" src="../renderer/assets/images/app help.png" style="height:20px; border: none;" onclick="GetHelpAddFolder()">        
    </div>
    <div id="table-scroll2" >
      <table id="dir_table">
          <tr class="grey">
            <th>Folders</th>            
          </tr>
      </table>    
    </div>    
    <div class="modal-bottom-buttons">
      <button id="btn-submit" style="font-size:20px; width:75px; height: 40px">OK</button>
      <button id="btn-close" style="font-size:20px; width:75px; height: 40px">Cancel</button>
      <button id="btn-back" style="font-size:20px; width:75px; height: 40px">Back</button>
    </div>    
  </section>  
  <div class="overlay hidden"></div>
  <!-- end of modal section-->  



  <p></p>
  <label>Pause loading new items between</label>
  <br>
  <label for="StartTime">Start</label>
  <select style="width:100px;" id="StartTime"></select>
  <label  style="padding-left:10px" for="StopTime">End</label>
  <select style="width:100px;" id="StopTime"></select>  
  <p></p>   
  <input type="checkbox" id="nightlybuild" name="nightlyrebuild">
  <label for="nightlybuild">Refresh playlists and item edits nightly</label>  
  <p></p>    
  <div class="bottom-buttons"  style="gap: 40px; margin-left: -10px;" >
    <button id="accept" name="accept" style="width:90px; height: 50px"  onclick="WriteDB()">Save</button>
    <button id="rebuildAll" name="rebuildAll" style="width:90px; height: 50px"  onclick="RebuildAll()">Save & Refresh</button>
    <button id="cancel" name="cancel" style="width:90px; height: 50px"  onclick="location.href='/appOptions';">Cancel</button>
  </div>

  <!-- Modals for disabling inputs while database or playlists are updating-->    
<div id="modalSavingCombined" style="
  display:none;
  position:fixed;
  top:0;
  left:0;
  width:100%;
  height:100%;
  background-color: rgba(0,0,0,0.5);
  z-index:999;
  align-items:center;
  justify-content:center;
">
  <div style="
    background:white;
    border:1px solid #888;
    padding:20px;
    box-shadow: 2px 2px 10px gray;
    width:90vw;
    max-width:400px;
    max-height:80vh;
    overflow-y:auto;
    box-sizing:border-box;

    /* Flexbox layout */
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
  ">
    <span style="flex:1; text-align:left;">
      Rebuilding Playlists and updating configuration settings
    </span>
    <img src="../renderer/assets/images/copyfiles.png" 
         alt="loading" 
         style="height:2.0em; flex-shrink:0;">
  </div>
</div>


</body>
<script type='text/javascript' src='appServer.js'></script>
<script src="../../common/customAlert.js"></script> 
<script>


// all UI elements
let playlists;  // holds g_playlist data returned from serverside read in DBFunctions.js
let selPLAYLIST = "";
let basedelay = 0;
let preloadNUM = 0;
let prefetchNUM = 0;
let startDirectory = "";
let StartTimeValue = 0;
let StopTimeValue = 0;
let nightlyrebuild = false; 
let appStartDir = ""; 
let SubDir = null; // used to store the next directory to load when double clicked
let SubLevelDir=[]; // used to store directories for back button in modal
let SystemDirs =[];  // store system directories for use in double click 

// modal information
const StartTime = document.getElementById("StartTime");
const StopTime = document.getElementById("StopTime");
const modal = document.querySelector(".modal");
const overlay = document.querySelector(".overlay");  
const closeModalBtn = document.querySelector("#btn-close");
const closeModalSubmit = document.querySelector("#btn-submit");
const backModalBtn = document.querySelector("#btn-back");

closeModalSubmit.addEventListener("click", closeModalSubmitted);
closeModalBtn.addEventListener("click", closeModalCancel); 
backModalBtn.addEventListener("click", backModalClicked);
document.getElementById("StartTime").addEventListener("change", handleTimeChange);
document.getElementById("StopTime").addEventListener("change", handleTimeChange);



function GetHelpAddFolder(){
  alert('Type the folder path directly or click the folder path to progress in the hierarchy to find the desired folder.  Click "Save" to add the folder path to the playlist.  Use the "Back" button to move up the current folder hierarchy path.  Use "Cancel" to exit without adding a folder to the playlist');
}

// rebuilds all playlists as well as all meta data
async function RebuildAll(){  
  await PrepMessage('app_writeDB');
  PrepMessage('appRebuildAll'); // rebuild all playlists and images  
}

function WriteDB(){
  PrepMessage('app_writeDB')
  location.href = '/appOptions'; // go back to options page after saving
}

async function PrepMessage(payload){
  let messagePayload = null;
  switch (payload){
    case 'TopImageDir':
      messagePayload = {command:"ImageDir", data:"TopDir" };
    break;
    case 'SubImageDir': 
      messagePayload = {command: "ImageDir", data: SubDir}; 
    break;
    case 'appRebuildAll': 
      document.getElementById('modalSavingCombined').style.display = 'flex';
      messagePayload = {command:"appRebuildAll", data:null };
    break;
    case 'ImageDir':
      messagePayload = {command:"ImageDir", data:"TopDir" };
    break;
    case 'app_writeDB':
      ReadUI();
      let data = {
        selPLAYLIST: selPLAYLIST,
        basedelay: basedelay,
        preloadNUM: preloadNUM,
        prefetchNUM: prefetchNUM, 
        StartTime: StartTimeValue,
        StopTime: StopTimeValue,
        nightlyrebuild: nightlyrebuild,
        appStartDir: appStartDir
      };
      messagePayload = {command: "app_writeDB",data: data}; 
    break;
    case 'app_readDB':
      messagePayload = {command:"app_readDB", data:""};
    break;
  } 

  try {
    // Await the response from the new, async makeRequest function.
    const returnData = await makeRequest('/app_sendrequest', messagePayload);
    command = returnData.command;
    data = returnData.data;
    // Handle the response based on the command.
    switch(messagePayload.command){
      case 'app_readDB':        
        return data;
      break;
      case 'ImageDir':        
        return data.data;
      break;
      case 'appRebuildAll':        
        if (data.data){           
          document.getElementById('modalSavingCombined').style.display = 'none';
          await ShowAlert("Error rebuilding one or more Playlists", false);
        } else {
          document.getElementById('modalSavingCombined').style.display = 'none';
          await ShowAlert("Update successfull", false);          
          location.href='/appOptions';
        } 
      break;

      default:          
      break;
    }      
  } catch (error) {      
    //ShowAlert('Error in html POST. '+ error, false).then((result) => { })    
  }
}

// start modal work

  document.getElementById('AppStartDirectory').addEventListener('click', function (e) {    
    openModal();    
  });

  document.getElementById('dir_table').addEventListener('click', async function (e) {
    if (e.target.tagName === 'TD') {
      document.getElementById('btn-submit').disabled = false;
      let row = e.target.parentElement.rowIndex;
      SubDir = SystemDirs[row + 1]; // get directory path of clicked row from global, store in global  
      SubLevelDir.push(SystemDirs[0]);                 
      result = await PrepMessage('SubImageDir')
      PopDirTable(result);      
    }    
  });


 async function openModal() {
    closeModalBtn.disabled = false;
    closeModalSubmit.disabled = false;      
    modal.classList.remove("hidden");
    overlay.classList.remove("hidden");  
    result = await PrepMessage('TopImageDir')
    PopDirTable(result);    
  }

  function closeModalCancel(){
    modal.classList.add("hidden");
    overlay.classList.add("hidden");
  }

  function closeModalSubmitted(){                
    document.getElementById('AppStartDirectory').value = document.getElementById('dirPath').value    
    closeModalBtn.disabled = true;      
    closeModalSubmit.disabled = true;   
    modal.classList.add("hidden");
    overlay.classList.add("hidden");
  }

  async function backModalClicked() {    
    if (SubLevelDir.length > 0) {
      SubDir = SubLevelDir.pop();
      result = await PrepMessage('SubImageDir')
        if (result != 'bad dir') {                       
          PopDirTable(result);          
          document.getElementById('btn-submit').disabled = false;
        } else {
          ShowAlert('Invalid Directory', false).then(() => {       
            })          
          document.getElementById('btn-submit').disabled = true;
        }              
    } else {
      result = await PrepMessage('TopImageDir')
      PopDirTable(result);      
    }
  }

  const dirInput = document.getElementById('dirPath');
  const modalSection = document.querySelector('.modal');

    // When user focuses the input (starts editing)
  dirInput.addEventListener('focus', () => {
    modalSection.classList.add('disabled-overlay');
  });

  // When user leaves the input (done editing)
  dirInput.addEventListener('blur', () => {
    modalSection.classList.remove('disabled-overlay');
  });

  async function handleDirInput() {
  SubDir = dirInput.value; // store the directory path in a global variable
  let result = await PrepMessage('SubImageDir');
  if (result != 'bad dir') {
    PopDirTable(result);
    document.getElementById('btn-submit').disabled = false;
  } else {
    ShowAlert('Invalid Directory', false).then(() => {       
      });
    document.getElementById('btn-submit').disabled = true;
  }  
}

// Run when user presses Enter
dirInput.addEventListener('keypress', async function (e) {
  if (e.which === 13 || e.key === "Enter") {
    await handleDirInput();
  }
});

// Run when user clicks off (field loses focus)
dirInput.addEventListener('blur', async function () {
  await handleDirInput();
});

function PopDirTable(SystemDirectories) {
  SystemDirs = SystemDirectories; // store global list of system directories for use when double clicked later
  document.getElementById('dirPath').value = SystemDirectories[0]; // first entry is the top level directory
  const dirTableBody = document.getElementById('dir_table').getElementsByTagName('tbody')[0];
  dirTableBody.innerHTML = ''; // clear existing rows
  SystemDirectories.forEach((data, index) => {
    if (index != 0) {
      const LastSlashIndex = data.lastIndexOf('\\');                  
        LastDir = data.slice(LastSlashIndex);                 
      newRow = dirTableBody.insertRow();
      newRow.innerHTML = `<td>${LastDir}</td>`; 
    }    
  });
}

// end modal work



function generateTimeOptions() {
  const times = [];
  for (let h = 0; h <= 24; h++) {
    for (let m = 0; m < 60; m += 30) {
      if (h === 24 && m > 0) break; // Ensure we don't go past 24:00
      let hour = String(h).padStart(2, '0');
      let minute = String(m).padStart(2, '0');
      times.push(`${hour}:${minute}`);
    }
  }
  return times;
}

function populateDropdown(dropdown, times) {
  dropdown.innerHTML = ""; // Clear existing options
  times.forEach(time => {
    let option = document.createElement("option");
    option.value = time;
    option.textContent = time;
    dropdown.appendChild(option);
  });
}

function getNextTime(startTime) {
  const times = generateTimeOptions();
  let index = times.indexOf(startTime);
  return index >= 0 && index < times.length - 1 ? times[index + 1] : times[times.length - 1];
}

function handleTimeChange() {
  let startTime = StartTime.value;
  let stopTime = StopTime.value;
  // If StartTime and StopTime are the same, adjust StopTime to be 30 minutes after StartTime
  if (startTime === stopTime) {
      StopTime.value = getNextTime(startTime);
  }
}


function prefetchcheck(){
  ReadUI(); // loads UI elements into global variables  
  if (prefetchNUM > preloadNUM){
    document.getElementById('prefetchNUM').value = preloadNUM;
  }
}

function parseplaylist(selectedplaylist){
  const playlistName = document.getElementById('playlist_name');
  playlistName.innerHTML = '';

  Object.keys(playlists).forEach(function(name){
    parts = name.split('_');
    displayName = parts[1];

    let remainingString = name.slice(9);  //remove 'playlist_'
    let new_name;
    if (remainingString.includes('_')){        
      new_name = remainingString.replace(/_/g, ','); 
      if (new_name.includes('$')){  
        new_name = new_name.replace('$', '!');
      }
    } else {
      new_name = remainingString;
    }
    const newOption = document.createElement('option');
    newOption.value = name;
    newOption.textContent = displayName;
    playlistName.appendChild(newOption);
  });

  playlistName.value = selectedplaylist; // set selected playlist

}


function ReadUI(){
  let new_name_val = document.getElementById('playlist_name').selectedOptions[0].value; 
  // ensure playlist name is formatted correctly before storing in database
  if (new_name_val.includes(',')) {
    new_name_val = new_name_val.replace(/,/g, '_');        
    if (new_name_val.includes('!')){  // ! is a reserved char for a table name
      new_name_val = new_name_val.replace('!', '$');
    }
  }      
  
  selPLAYLIST = new_name_val;
  basedelay = document.getElementById('baseDELAY').value; 
  //preloadNUM = document.getElementById('preloadNUM').value;
  preloadNUM = parseInt(document.getElementById('preloadNUM').value, 10);
  //prefetchNUM = document.getElementById('prefetchNUM').value;  
  prefetchNUM = parseInt(document.getElementById('prefetchNUM').value, 10);
  StartTimeValue = document.getElementById('StartTime').value;  
  StopTimeValue = document.getElementById('StopTime').value;
  nightlyrebuild = document.getElementById('nightlybuild').checked;
  appStartDir = document.getElementById('AppStartDirectory').value; 
}

function WriteUI(data){
  playlists = data.playlists;        
  document.getElementById('baseDELAY').value = parseInt(data.basedelay);
  document.getElementById('preloadNUM').value = parseInt(data.preload);
  document.getElementById('prefetchNUM').value = data.prefetch;            
  parseplaylist('playlist_'+ data.selplaylist);
  document.getElementById('nightlybuild').checked = data.nightlyrebuild;
  document.getElementById('AppStartDirectory').value = data.appStartDir;   
  let timeOptions = generateTimeOptions();
  populateDropdown(StartTime, timeOptions);
  populateDropdown(StopTime, timeOptions);
  StartTime.value = data.startPauseTime;
  StopTime.value = data.stopPauseTime;
}

async function initialize(){
  result = await PrepMessage('app_readDB')
  WriteUI(result);    
};


</script>

</html>
